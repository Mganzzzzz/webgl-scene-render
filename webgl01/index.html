<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <link rel="icon" type="image/svg+xml" href="favicon.svg"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Vite App</title>
    <style>
        body {
            background-color: #504444;
        }

        canvas {
            border: 1px solid lightblue;
        }
    </style>
</head>
<script type="x-shader/x-vertex" id="test.vs">
    // an attribute will receive data from a buffer
    precision mediump float;

    attribute vec4 position;
    attribute vec4 color;
    attribute vec2 texcoord;
    uniform mat4 M;
    uniform mat4 P;
    uniform mat4 V;
    varying vec4 V_Color;
    varying vec2 V_texcord;

    void main() {
        V_Color=color;
        V_texcord = texcoord;
        gl_Position=P*V*M*position;
    }

</script>
<script type="x-shader/x-fragment" id="test.fs">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
    varying vec4 V_Color;
    varying vec2 V_texcord;
    uniform sampler2D U_texture;
    void main() {
        // gl_FragColor is a special variable a fragment shader
        // is responsible for setting
        gl_FragColor = V_Color * texture2D(U_texture, V_texcord);;// return redish-purple
    }
</script>
<script type="x-shader/x-vertex" id="ground.vs">
    // an attribute will receive data from a buffer
    precision mediump float;

    attribute vec4 position;
    attribute vec4 color;
    attribute vec2 texcoord;
    uniform mat4 M;
    uniform mat4 P;
    uniform mat4 V;
    varying vec4 V_Color;
    varying vec2 V_texcord;

    void main() {
        V_Color=color;
        V_texcord = texcoord;
        gl_Position=P*V*M*position;
    }

</script>
<script type="x-shader/x-fragment" id="ground.fs">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
    varying vec4 V_Color;
    varying vec2 V_texcord;
    uniform sampler2D U_texture;
    void main() {
        // gl_FragColor is a special variable a fragment shader
        // is responsible for setting
        gl_FragColor = texture2D(U_texture, V_texcord);;// return redish-purple
    }
</script>

<script type="x-shader/x-vertex" id="light.vs">
    precision mediump float;

    attribute vec4 position;
    attribute vec4 color;
    attribute vec2 texcoord;
    attribute vec4 normal;
    uniform mat4 M;
    uniform mat4 P;
    uniform mat4 V;
    // 环境光
    uniform vec4 U_AmbientMaterial;
    uniform vec4 U_AmbientLightColor;
    // 漫反射
    uniform vec4 U_DiffuseMaterial;
    uniform vec4 U_DiffuseLightColor;

    // 法线矩阵
    uniform mat4 IT_ModelMatrix;
    //光源位置
    uniform vec4 U_LightPos;

    varying vec4 V_Color;

    void main() {
        vec3 L= U_LightPos.xyz;
        vec4 world_pos = M * position;
        vec3 OL = U_LightPos.xyz - world_pos.xyz;
        float d = length(OL);// 光源距离当前面的距离
        OL = normalize(OL); // 点光源方向计算
//        L=normalize(L);// 求出物体表面射向光源的向量
        vec3 n=normalize((IT_ModelMatrix*normal).xyz);//求法线 方便计算光照强度
        float diffuseIntensity=max(0.0, dot(OL, n));//有时光照强度计算为负 所以用 max 和0 对比
        vec4 diffuseColor=U_DiffuseLightColor*U_DiffuseMaterial*diffuseIntensity*color;// 漫反射颜色
        V_Color=U_AmbientMaterial*U_AmbientLightColor+diffuseColor;
        gl_Position=P*V*M*position;
    }

</script>
<script type="x-shader/x-fragment" id="light.fs">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
    //    varying vec4 V_Color;
    varying vec4 V_Color;
    void main() {
        gl_FragColor= V_Color;
    }
</script>
<script type="x-shader/x-vertex" id="light_color.vs">
    precision mediump float;
    attribute vec4 position;
    attribute vec4 color;
    attribute vec4 texcoord;
    attribute vec4 normal;
    uniform mat4 M;
    uniform mat4 P;
    uniform mat4 V;
    uniform mat4 IT_M;// inverse transpose model matrix 逆转置模型矩阵
    varying vec4 V_texcord;
    varying vec4 V_WorldPos;
    varying vec3 V_Normal;
    void main(){
        V_texcord = texcoord;
        vec4 world_pos = M * position;
        V_Normal = normalize((IT_M * normal).xyz);
        V_WorldPos= world_pos;
        gl_Position=P*V*M*position;
    }


</script>
<script type="x-shader/x-fragment" id="light_color.fs">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;
    varying vec4 V_WorldPos;
    varying vec3 V_Normal;
    varying vec4 V_texcord;

    uniform sampler2D U_texture;
    uniform vec4 U_AmbientMaterial;
    uniform vec4 U_AmbientLight;

    uniform vec4 U_DiffuseMaterial;
    uniform vec4 U_DiffuseLight;

    uniform vec4 U_SpecularMaterial;
    uniform vec4 U_SpecularLight;
    uniform vec4 U_CameraPos;
    uniform vec4 U_LightPos;
    uniform vec4 U_Setting;

    void main(){
        vec4 texture_color = texture2D(U_texture, V_texcord.xy);
        vec3 light_pos = U_LightPos.xyz;
        vec3 n = normalize(V_Normal.xyz);// 法线
        vec3 OL = light_pos - V_WorldPos.xyz;
        float d = length(OL);// 光源距离当前面的距离
        OL = normalize(OL);

        float constant_factor = 1.0;//设置因子
        float linear_factor = 0.5;
        float quadratic_factor = 0.0;
        float attenuation  = 1.0 / (constant_factor + linear_factor *d + d*d*quadratic_factor);
        float diffuse_intensity = max(dot(n, OL), 0.0);// 漫反射强度
        vec3 speclar_color =vec3(0.0, 0.0, 0.0);
        vec3 diffuse_color = vec3(0.0, 0.0, 0.0);

        if (diffuse_intensity > 0.0) { //如果漫反射的强度大于0 则开始计算镜面反射
            diffuse_color = U_DiffuseMaterial.rgb * U_DiffuseLight.rgb * attenuation * diffuse_intensity;
            if (U_Setting.x==1.0){
                vec3 reflect_l = reflect(-OL, n);// 计算反射光线  reflect函数 通过 入射光线-OL, 法线n 算出反射光线
                vec3 viewDirection =U_CameraPos.xyz - V_WorldPos.xyz;//计算射入到摄像机位置vec3(0.0, 2.0, 5.0)的光线
                viewDirection = normalize(viewDirection);// 单位化
                reflect_l = normalize(reflect_l);
                float shiness  = 10.0;// 反光强度
                //计算出镜面反射
                speclar_color = U_SpecularMaterial.rgb * U_SpecularLight.rgb * pow(max(dot(viewDirection, reflect_l), 0.0), shiness);
            }
        }

        vec3 ambient_color = U_AmbientMaterial.rgb * U_AmbientLight.rgb;
        vec3 final_color = (ambient_color+diffuse_color+speclar_color)* texture_color.rgb;
        gl_FragColor= vec4(final_color, 1.0);
    }

</script>


<body>
<!--<div id="app"></div>-->
<script src="webgl-utils.js"></script>
<script src="m4.js"></script>
<canvas id="c" width="800" height="600"></canvas>
<script>
    window.canvas = document.querySelector("#c");
    window.gl = canvas.getContext("webgl");
</script>

<script type="module" src="/src/main.js"></script>
</body>
</html>
